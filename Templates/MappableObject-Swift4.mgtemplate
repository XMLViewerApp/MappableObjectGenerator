import Foundation

protocol {{ mapping.unqualifiedObjectClassName }}: {% if mapping.parentName != nil %}{{ mapping.parentName }}{% else %}Codable{% /if %} {
    {% for fieldMapping in mapping.fieldMappings %}
    var {{ fieldMapping.fieldName }}: {{ fieldMapping.swiftFieldClassName }}? { get set }
    {% /for %}
}

struct {{ mapping.unqualifiedObjectClassName }}DTO: {{ mapping.unqualifiedObjectClassName }} {
    enum CodingKeys: String, CodingKey {
        {% for fieldMapping in mapping.fieldMappings %}
        case {{ fieldMapping.fieldName }} = "{{ fieldMapping.mappingPath }}"
        {% /for %}
    }

    init() {

    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        {% for fieldMapping in mapping.fieldMappings %}
        {{ fieldMapping.fieldName }} = try container.decodeIfPresent({{ fieldMapping.swiftFieldClassName }}{% if fieldMapping.fieldObjectClassIsCustom %}DTO{% /if %}.self, forKey: .{{ fieldMapping.fieldName }})
        {% /for %}
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        {% for fieldMapping in mapping.fieldMappings %}
        try container.encodeIfPresent({{ fieldMapping.fieldName }}{% if fieldMapping.fieldObjectClassIsCustom %} as? {{ fieldMapping.swiftFieldClassName }}DTO{% /if %}, forKey: .{{ fieldMapping.fieldName }})
        {% /for %}
    }

    {% for fieldMapping in mapping.fieldMappings %}
    var {{ fieldMapping.fieldName }}: {{ fieldMapping.swiftFieldClassName }}?{% if fieldMapping.fieldObjectClassIsCustom %} {
        willSet(newValue) {
precondition(newValue == nil || newValue is {{ fieldMapping.swiftFieldClassName }}DTO, "New value should be an instance of {{ fieldMapping.swiftFieldClassName }}DTO but was: \(String(describing: newValue))")
        }
    }{% /if %}
    {% /for %}
}
